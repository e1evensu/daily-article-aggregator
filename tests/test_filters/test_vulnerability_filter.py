"""
VulnerabilityFilter 单元测试和属性测试
Unit tests and property-based tests for VulnerabilityFilter

测试智能漏洞过滤器的各项功能。
Tests for smart vulnerability filter functionality.
"""

import pytest
from unittest.mock import patch, MagicMock

from src.filters.vulnerability_filter import (
    VulnerabilityFilter,
    VulnerabilityFilterResult,
    filter_vulnerability,
)


class TestVulnerabilityFilterInit:
    """测试 VulnerabilityFilter 初始化"""
    
    def test_default_config(self):
        """测试默认配置"""
        filter = VulnerabilityFilter({})
        
        assert filter.github_star_threshold == 1000
        assert filter.ip_asset_threshold == 300
        assert filter.enable_ai_assessment is True
        assert filter.github_token is None
    
    def test_custom_config(self):
        """测试自定义配置"""
        config = {
            'github_star_threshold': 500,
            'ip_asset_threshold': 100,
            'enable_ai_assessment': False,
            'github_token': 'test-token'
        }
        filter = VulnerabilityFilter(config)
        
        assert filter.github_star_threshold == 500
        assert filter.ip_asset_threshold == 100
        assert filter.enable_ai_assessment is False
        assert filter.github_token == 'test-token'


class TestGitHubUrlExtraction:
    """测试 GitHub URL 提取"""
    
    def test_extract_from_description(self):
        """测试从描述中提取 GitHub URL"""
        filter = VulnerabilityFilter({})
        vuln = {
            'description': 'Vulnerability in https://github.com/user/repo project'
        }
        
        urls = filter._extract_github_urls(vuln)
        
        assert len(urls) == 1
        assert urls[0] == 'https://github.com/user/repo'
    
    def test_extract_from_references(self):
        """测试从引用中提取 GitHub URL"""
        filter = VulnerabilityFilter({})
        vuln = {
            'description': 'Test vulnerability',
            'references': [
                {'url': 'https://github.com/owner/project'},
                {'url': 'https://example.com/other'}
            ]
        }
        
        urls = filter._extract_github_urls(vuln)
        
        assert len(urls) == 1
        assert urls[0] == 'https://github.com/owner/project'
    
    def test_no_github_urls(self):
        """测试没有 GitHub URL 的情况"""
        filter = VulnerabilityFilter({})
        vuln = {
            'description': 'Test vulnerability without GitHub links'
        }
        
        urls = filter._extract_github_urls(vuln)
        
        assert len(urls) == 0


class TestFilterVulnerability:
    """测试 filter_vulnerability 函数"""
    
    def test_pass_with_high_stars(self):
        """测试高 star 数通过"""
        vuln = {'cve_id': 'CVE-2024-1234'}
        result = filter_vulnerability(
            vuln, 
            github_stars=2000, 
            github_star_threshold=1000
        )
        
        assert result.passed is True
        assert result.github_stars == 2000
        assert len(result.filter_reasons) == 0
    
    def test_fail_with_low_stars(self):
        """测试低 star 数被过滤"""
        vuln = {'cve_id': 'CVE-2024-1234'}
        result = filter_vulnerability(
            vuln, 
            github_stars=500, 
            github_star_threshold=1000
        )
        
        assert result.passed is False
        assert result.github_stars == 500
        assert len(result.filter_reasons) == 1
        assert 'GitHub stars' in result.filter_reasons[0]
    
    def test_pass_with_high_ip_assets(self):
        """测试高 IP 资产数通过"""
        vuln = {'cve_id': 'CVE-2024-1234'}
        result = filter_vulnerability(
            vuln, 
            ip_asset_count=500, 
            ip_asset_threshold=300
        )
        
        assert result.passed is True
        assert result.ip_asset_count == 500
    
    def test_fail_with_low_ip_assets(self):
        """测试低 IP 资产数被过滤"""
        vuln = {'cve_id': 'CVE-2024-1234'}
        result = filter_vulnerability(
            vuln, 
            ip_asset_count=100, 
            ip_asset_threshold=300
        )
        
        assert result.passed is False
        assert result.ip_asset_count == 100
        assert len(result.filter_reasons) == 1
        assert 'IP asset count' in result.filter_reasons[0]
    
    def test_fail_with_both_low(self):
        """测试两个指标都低被过滤"""
        vuln = {'cve_id': 'CVE-2024-1234'}
        result = filter_vulnerability(
            vuln, 
            github_stars=500, 
            github_star_threshold=1000,
            ip_asset_count=100, 
            ip_asset_threshold=300
        )
        
        assert result.passed is False
        assert len(result.filter_reasons) == 2
    
    def test_pass_without_metrics(self):
        """测试没有指标时通过"""
        vuln = {'cve_id': 'CVE-2024-1234'}
        result = filter_vulnerability(vuln)
        
        assert result.passed is True
        assert result.github_stars is None
        assert result.ip_asset_count is None


class TestVulnerabilityFilterBatch:
    """测试批量过滤"""
    
    def test_filter_multiple(self):
        """测试批量过滤多个漏洞"""
        filter = VulnerabilityFilter({
            'github_star_threshold': 1000,
            'enable_ai_assessment': False
        })
        
        vulnerabilities = [
            {'cve_id': 'CVE-2024-0001', 'ip_asset_count': 500},
            {'cve_id': 'CVE-2024-0002', 'ip_asset_count': 100},
            {'cve_id': 'CVE-2024-0003', 'ip_asset_count': 1000},
        ]
        
        results = filter.filter_vulnerabilities(vulnerabilities)
        
        assert len(results) == 3
        
        passed = filter.get_passed_vulnerabilities(results)
        filtered = filter.get_filtered_vulnerabilities(results)
        
        assert len(passed) == 2
        assert len(filtered) == 1


# =============================================================================
# Property-Based Tests (属性测试)
# =============================================================================

from hypothesis import given, strategies as st, settings


# Strategy for generating valid CVE IDs
cve_id_strategy = st.from_regex(r'CVE-20[0-9]{2}-[0-9]{4,7}', fullmatch=True)

# Strategy for generating GitHub stars
github_stars_strategy = st.integers(min_value=0, max_value=1000000)

# Strategy for generating IP asset counts
ip_asset_count_strategy = st.integers(min_value=0, max_value=10000000)

# Strategy for generating thresholds
threshold_strategy = st.integers(min_value=0, max_value=100000)

# Strategy for generating vulnerability data
vulnerability_strategy = st.fixed_dictionaries({
    'cve_id': cve_id_strategy,
    'description': st.text(min_size=0, max_size=500),
})


@given(
    vulnerability_strategy,
    github_stars_strategy,
    threshold_strategy,
)
@settings(max_examples=100)
def test_property_vulnerability_filtering_by_github_stars(
    vuln: dict,
    github_stars: int,
    threshold: int,
):
    """
    Feature: aggregator-advanced-features, Property 8: Vulnerability Filtering by Threshold
    
    **Validates: Requirements 5.1, 6.1**
    
    对于任意漏洞及其关联指标（GitHub stars），如果指标低于配置的阈值，
    漏洞应被标记为低优先级，并记录相应的过滤原因。
    
    For any vulnerability with associated metrics (GitHub stars), if any metric
    is below its configured threshold, the vulnerability SHALL be marked as low
    priority with the appropriate filter reason recorded.
    """
    result = filter_vulnerability(
        vuln,
        github_stars=github_stars,
        github_star_threshold=threshold,
    )
    
    # Property: If stars < threshold, should be filtered
    if github_stars < threshold:
        assert result.passed is False, \
            f"Vulnerability with {github_stars} stars should be filtered (threshold: {threshold})"
        assert any('GitHub stars' in reason for reason in result.filter_reasons), \
            "Filter reason should mention GitHub stars"
    else:
        # Property: If stars >= threshold, should pass (for this metric)
        assert result.passed is True, \
            f"Vulnerability with {github_stars} stars should pass (threshold: {threshold})"
    
    # Property: github_stars should be recorded
    assert result.github_stars == github_stars, \
        "GitHub stars should be recorded in result"


@given(
    vulnerability_strategy,
    ip_asset_count_strategy,
    threshold_strategy,
)
@settings(max_examples=100)
def test_property_vulnerability_filtering_by_ip_assets(
    vuln: dict,
    ip_asset_count: int,
    threshold: int,
):
    """
    Feature: aggregator-advanced-features, Property 8: Vulnerability Filtering by Threshold
    
    **Validates: Requirements 5.1, 6.1**
    
    对于任意漏洞及其关联指标（IP 资产数），如果指标低于配置的阈值，
    漏洞应被标记为低优先级，并记录相应的过滤原因。
    
    For any vulnerability with associated metrics (IP asset count), if any metric
    is below its configured threshold, the vulnerability SHALL be marked as low
    priority with the appropriate filter reason recorded.
    """
    result = filter_vulnerability(
        vuln,
        ip_asset_count=ip_asset_count,
        ip_asset_threshold=threshold,
    )
    
    # Property: If count < threshold, should be filtered
    if ip_asset_count < threshold:
        assert result.passed is False, \
            f"Vulnerability with {ip_asset_count} IP assets should be filtered (threshold: {threshold})"
        assert any('IP asset count' in reason for reason in result.filter_reasons), \
            "Filter reason should mention IP asset count"
    else:
        # Property: If count >= threshold, should pass (for this metric)
        assert result.passed is True, \
            f"Vulnerability with {ip_asset_count} IP assets should pass (threshold: {threshold})"
    
    # Property: ip_asset_count should be recorded
    assert result.ip_asset_count == ip_asset_count, \
        "IP asset count should be recorded in result"


@given(
    vulnerability_strategy,
    github_stars_strategy,
    ip_asset_count_strategy,
    threshold_strategy,
    threshold_strategy,
)
@settings(max_examples=100)
def test_property_configuration_threshold_respect(
    vuln: dict,
    github_stars: int,
    ip_asset_count: int,
    github_threshold: int,
    ip_threshold: int,
):
    """
    Feature: aggregator-advanced-features, Property 9: Configuration Threshold Respect
    
    **Validates: Requirements 5.3, 6.2**
    
    对于任意配置的阈值值，过滤和分类逻辑应使用配置的值而不是默认值。
    
    For any configured threshold value, the filtering and categorization logic
    SHALL use the configured value instead of defaults.
    """
    result = filter_vulnerability(
        vuln,
        github_stars=github_stars,
        ip_asset_count=ip_asset_count,
        github_star_threshold=github_threshold,
        ip_asset_threshold=ip_threshold,
    )
    
    # Calculate expected result
    github_pass = github_stars >= github_threshold
    ip_pass = ip_asset_count >= ip_threshold
    expected_pass = github_pass and ip_pass
    
    # Property: Result should match expected based on configured thresholds
    assert result.passed == expected_pass, \
        f"Result {result.passed} should match expected {expected_pass} " \
        f"(stars: {github_stars}/{github_threshold}, ip: {ip_asset_count}/{ip_threshold})"
    
    # Property: Filter reasons should be recorded for each failed metric
    if not github_pass:
        assert any('GitHub stars' in reason for reason in result.filter_reasons), \
            "Should have GitHub stars filter reason"
    if not ip_pass:
        assert any('IP asset count' in reason for reason in result.filter_reasons), \
            "Should have IP asset count filter reason"


@given(st.lists(vulnerability_strategy, min_size=0, max_size=20))
@settings(max_examples=50)
def test_property_batch_filtering_consistency(vulnerabilities: list[dict]):
    """
    Feature: aggregator-advanced-features, Property 8: Vulnerability Filtering by Threshold (Batch)
    
    **Validates: Requirements 5.1, 6.1**
    
    批量过滤应该与单个过滤产生一致的结果。
    Batch filtering should produce consistent results with single filtering.
    """
    filter = VulnerabilityFilter({
        'github_star_threshold': 1000,
        'ip_asset_threshold': 300,
        'enable_ai_assessment': False,
    })
    
    results = filter.filter_vulnerabilities(vulnerabilities)
    
    # Property: Result count should match input count
    assert len(results) == len(vulnerabilities), \
        "Result count should match input count"
    
    # Property: Each result should have the original vulnerability
    for i, result in enumerate(results):
        assert result.vulnerability == vulnerabilities[i], \
            f"Result {i} should contain original vulnerability"


# =============================================================================
# AI Assessment Tests (AI 评估测试)
# =============================================================================

from unittest.mock import patch, MagicMock


class TestAIAssessmentResultStructure:
    """
    测试 AI 评估结果结构
    Test AI Assessment Result Structure
    
    **Property 11: AI Assessment Result Structure**
    **Validates: Requirements 7.4**
    """
    
    @patch('src.analyzers.ai_analyzer.OpenAI')
    def test_successful_assessment_has_required_fields(self, mock_openai_class):
        """
        测试成功的 AI 评估包含所有必需字段
        Test successful AI assessment contains all required fields
        
        **Validates: Requirements 7.4**
        """
        from src.analyzers.ai_analyzer import AIAnalyzer
        
        mock_client = MagicMock()
        mock_openai_class.return_value = mock_client
        
        # Mock a valid JSON response
        mock_response = MagicMock()
        mock_response.choices = [MagicMock()]
        mock_response.choices[0].message.content = '''
        {
            "is_significant": true,
            "assessment": "该漏洞允许远程代码执行，具有高危害性",
            "reasons": ["利用难度低", "影响范围广"]
        }
        '''
        mock_client.chat.completions.create.return_value = mock_response
        
        analyzer = AIAnalyzer({'api_key': 'test'})
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Remote code execution vulnerability',
            'cvss_score': 9.8
        }
        
        result = analyzer.assess_vulnerability(vuln)
        
        # Property: Result must contain is_significant (boolean)
        assert result is not None
        assert 'is_significant' in result
        assert isinstance(result['is_significant'], bool)
        
        # Property: Result must contain assessment (string)
        assert 'assessment' in result
        assert isinstance(result['assessment'], str)
        
        # Property: Result must contain reasons (list of strings)
        assert 'reasons' in result
        assert isinstance(result['reasons'], list)
    
    @patch('src.analyzers.ai_analyzer.OpenAI')
    def test_assessment_failure_returns_none(self, mock_openai_class):
        """
        测试 AI 评估失败返回 None
        Test AI assessment failure returns None
        
        **Validates: Requirements 7.5**
        """
        from src.analyzers.ai_analyzer import AIAnalyzer
        from openai import APITimeoutError
        
        mock_client = MagicMock()
        mock_openai_class.return_value = mock_client
        mock_client.chat.completions.create.side_effect = APITimeoutError(request=MagicMock())
        
        analyzer = AIAnalyzer({'api_key': 'test'})
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability'
        }
        
        result = analyzer.assess_vulnerability(vuln)
        
        # Property: On failure, result should be None (vulnerability retained)
        assert result is None
    
    @patch('src.analyzers.ai_analyzer.OpenAI')
    def test_invalid_json_response_returns_none(self, mock_openai_class):
        """
        测试无效 JSON 响应返回 None
        Test invalid JSON response returns None
        
        **Validates: Requirements 7.5**
        """
        from src.analyzers.ai_analyzer import AIAnalyzer
        
        mock_client = MagicMock()
        mock_openai_class.return_value = mock_client
        
        # Mock an invalid JSON response
        mock_response = MagicMock()
        mock_response.choices = [MagicMock()]
        mock_response.choices[0].message.content = "This is not valid JSON"
        mock_client.chat.completions.create.return_value = mock_response
        
        analyzer = AIAnalyzer({'api_key': 'test'})
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability'
        }
        
        result = analyzer.assess_vulnerability(vuln)
        
        # Property: On invalid JSON, result should be None
        assert result is None
    
    @patch('src.analyzers.ai_analyzer.OpenAI')
    def test_missing_is_significant_returns_none(self, mock_openai_class):
        """
        测试缺少 is_significant 字段返回 None
        Test missing is_significant field returns None
        
        **Validates: Requirements 7.4**
        """
        from src.analyzers.ai_analyzer import AIAnalyzer
        
        mock_client = MagicMock()
        mock_openai_class.return_value = mock_client
        
        # Mock a response missing is_significant
        mock_response = MagicMock()
        mock_response.choices = [MagicMock()]
        mock_response.choices[0].message.content = '''
        {
            "assessment": "Some assessment",
            "reasons": ["reason1"]
        }
        '''
        mock_client.chat.completions.create.return_value = mock_response
        
        analyzer = AIAnalyzer({'api_key': 'test'})
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability'
        }
        
        result = analyzer.assess_vulnerability(vuln)
        
        # Property: Missing required field should return None
        assert result is None
    
    def test_empty_description_returns_none(self):
        """
        测试空描述返回 None
        Test empty description returns None
        """
        from src.analyzers.ai_analyzer import AIAnalyzer
        
        analyzer = AIAnalyzer({'api_key': 'test'})
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': ''
        }
        
        result = analyzer.assess_vulnerability(vuln)
        
        assert result is None


# Property-based test for AI Assessment Result Structure
@given(
    st.fixed_dictionaries({
        'is_significant': st.booleans(),
        'assessment': st.text(min_size=0, max_size=500),
        'reasons': st.lists(st.text(min_size=1, max_size=100), min_size=0, max_size=10)
    })
)
@settings(max_examples=50)
def test_property_ai_assessment_result_structure(assessment_result: dict):
    """
    Feature: aggregator-advanced-features, Property 11: AI Assessment Result Structure
    
    **Validates: Requirements 7.4**
    
    对于任意成功的 AI 漏洞评估，结果应包含：is_significant (boolean)、
    assessment (string) 和 reasons (list of strings)。
    
    For any successful AI vulnerability assessment, the result SHALL contain:
    is_significant (boolean), assessment (string), and reasons (list of strings).
    """
    # Property: is_significant must be boolean
    assert isinstance(assessment_result['is_significant'], bool), \
        "is_significant must be a boolean"
    
    # Property: assessment must be string
    assert isinstance(assessment_result['assessment'], str), \
        "assessment must be a string"
    
    # Property: reasons must be a list
    assert isinstance(assessment_result['reasons'], list), \
        "reasons must be a list"
    
    # Property: all reasons must be strings
    for reason in assessment_result['reasons']:
        assert isinstance(reason, str), \
            "each reason must be a string"



# =============================================================================
# AI Assessment Flow Tests (AI 评估流程测试)
# =============================================================================

class TestAIAssessmentFlow:
    """
    测试 AI 评估流程
    Test AI Assessment Flow
    
    **Property 10: AI Assessment Failure Handling**
    **Property 12: AI Assessment Triggers After Basic Filters**
    **Validates: Requirements 7.1, 7.5**
    """
    
    def test_ai_assessment_not_called_when_github_filter_fails(self):
        """
        测试 GitHub 过滤失败时不调用 AI 评估
        Test AI assessment not called when GitHub filter fails
        
        **Property 12: AI Assessment Triggers After Basic Filters**
        **Validates: Requirements 7.1**
        """
        # Create a mock AI analyzer
        mock_ai_analyzer = MagicMock()
        
        filter = VulnerabilityFilter({
            'github_star_threshold': 1000,
            'ip_asset_threshold': 300,
            'enable_ai_assessment': True
        }, ai_analyzer=mock_ai_analyzer)
        
        # Vulnerability with low GitHub stars (will fail basic filter)
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability',
            'ip_asset_count': 500,  # Passes IP filter
        }
        
        # Mock _check_github_stars to return failure
        with patch.object(filter, '_check_github_stars', return_value=(False, 100)):
            result = filter.filter_single(vuln)
        
        # Property: AI assessment should NOT be called when basic filter fails
        mock_ai_analyzer.assess_vulnerability.assert_not_called()
        assert result.passed is False
    
    def test_ai_assessment_not_called_when_ip_filter_fails(self):
        """
        测试 IP 资产过滤失败时不调用 AI 评估
        Test AI assessment not called when IP asset filter fails
        
        **Property 12: AI Assessment Triggers After Basic Filters**
        **Validates: Requirements 7.1**
        """
        mock_ai_analyzer = MagicMock()
        
        filter = VulnerabilityFilter({
            'github_star_threshold': 1000,
            'ip_asset_threshold': 300,
            'enable_ai_assessment': True
        }, ai_analyzer=mock_ai_analyzer)
        
        # Vulnerability with low IP assets (will fail basic filter)
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability',
            'ip_asset_count': 100,  # Fails IP filter
        }
        
        # Mock _check_github_stars to return success
        with patch.object(filter, '_check_github_stars', return_value=(True, None)):
            result = filter.filter_single(vuln)
        
        # Property: AI assessment should NOT be called when basic filter fails
        mock_ai_analyzer.assess_vulnerability.assert_not_called()
        assert result.passed is False
    
    def test_ai_assessment_called_when_basic_filters_pass(self):
        """
        测试基础过滤通过后调用 AI 评估
        Test AI assessment called when basic filters pass
        
        **Property 12: AI Assessment Triggers After Basic Filters**
        **Validates: Requirements 7.1**
        """
        mock_ai_analyzer = MagicMock()
        mock_ai_analyzer.assess_vulnerability.return_value = {
            'is_significant': True,
            'assessment': 'High impact vulnerability',
            'reasons': ['Easy to exploit']
        }
        
        filter = VulnerabilityFilter({
            'github_star_threshold': 1000,
            'ip_asset_threshold': 300,
            'enable_ai_assessment': True
        }, ai_analyzer=mock_ai_analyzer)
        
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability',
            'ip_asset_count': 500,  # Passes IP filter
        }
        
        # Mock _check_github_stars to return success
        with patch.object(filter, '_check_github_stars', return_value=(True, 2000)):
            result = filter.filter_single(vuln)
        
        # Property: AI assessment SHOULD be called when basic filters pass
        mock_ai_analyzer.assess_vulnerability.assert_called_once_with(vuln)
        assert result.passed is True
    
    def test_ai_assessment_failure_preserves_vulnerability(self):
        """
        测试 AI 评估失败时保留漏洞
        Test AI assessment failure preserves vulnerability
        
        **Property 10: AI Assessment Failure Handling**
        **Validates: Requirements 7.5**
        """
        mock_ai_analyzer = MagicMock()
        # AI assessment returns None (failure)
        mock_ai_analyzer.assess_vulnerability.return_value = None
        
        filter = VulnerabilityFilter({
            'github_star_threshold': 1000,
            'ip_asset_threshold': 300,
            'enable_ai_assessment': True
        }, ai_analyzer=mock_ai_analyzer)
        
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability',
            'ip_asset_count': 500,
        }
        
        with patch.object(filter, '_check_github_stars', return_value=(True, 2000)):
            result = filter.filter_single(vuln)
        
        # Property: On AI failure, vulnerability should be RETAINED (passed=True)
        assert result.passed is True
        assert result.ai_assessment is None
    
    def test_ai_assessment_exception_preserves_vulnerability(self):
        """
        测试 AI 评估异常时保留漏洞
        Test AI assessment exception preserves vulnerability
        
        **Property 10: AI Assessment Failure Handling**
        **Validates: Requirements 7.5**
        """
        mock_ai_analyzer = MagicMock()
        # AI assessment raises exception
        mock_ai_analyzer.assess_vulnerability.side_effect = Exception("API Error")
        
        filter = VulnerabilityFilter({
            'github_star_threshold': 1000,
            'ip_asset_threshold': 300,
            'enable_ai_assessment': True
        }, ai_analyzer=mock_ai_analyzer)
        
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability',
            'ip_asset_count': 500,
        }
        
        with patch.object(filter, '_check_github_stars', return_value=(True, 2000)):
            result = filter.filter_single(vuln)
        
        # Property: On AI exception, vulnerability should be RETAINED (passed=True)
        assert result.passed is True
    
    def test_ai_assessment_water_hole_filters_vulnerability(self):
        """
        测试 AI 判定为"水洞"时过滤漏洞
        Test AI assessment marks "water hole" as filtered
        
        **Validates: Requirements 7.3**
        """
        mock_ai_analyzer = MagicMock()
        # AI assessment returns is_significant=False (water hole)
        mock_ai_analyzer.assess_vulnerability.return_value = {
            'is_significant': False,
            'assessment': '该漏洞为水洞，实际危害有限',
            'reasons': ['利用条件苛刻', '影响范围有限']
        }
        
        filter = VulnerabilityFilter({
            'github_star_threshold': 1000,
            'ip_asset_threshold': 300,
            'enable_ai_assessment': True
        }, ai_analyzer=mock_ai_analyzer)
        
        vuln = {
            'cve_id': 'CVE-2024-1234',
            'description': 'Test vulnerability',
            'ip_asset_count': 500,
        }
        
        with patch.object(filter, '_check_github_stars', return_value=(True, 2000)):
            result = filter.filter_single(vuln)
        
        # Property: Water hole should be filtered (passed=False)
        assert result.passed is False
        assert 'AI assessment' in result.filter_reasons[0]


# Property-based tests for AI Assessment Flow

@given(
    vulnerability_strategy,
    github_stars_strategy,
    ip_asset_count_strategy,
    threshold_strategy,
    threshold_strategy,
)
@settings(max_examples=50)
def test_property_ai_assessment_triggers_after_basic_filters(
    vuln: dict,
    github_stars: int,
    ip_asset_count: int,
    github_threshold: int,
    ip_threshold: int,
):
    """
    Feature: aggregator-advanced-features, Property 12: AI Assessment Triggers After Basic Filters
    
    **Validates: Requirements 7.1**
    
    对于任意漏洞，如果基础过滤（GitHub stars 或 IP 资产）失败，
    AI 评估不应被调用。
    
    For any vulnerability that fails basic filters (GitHub stars or IP assets
    below threshold), AI assessment SHALL NOT be invoked for that vulnerability.
    """
    mock_ai_analyzer = MagicMock()
    mock_ai_analyzer.assess_vulnerability.return_value = {
        'is_significant': True,
        'assessment': 'Test',
        'reasons': []
    }
    
    filter = VulnerabilityFilter({
        'github_star_threshold': github_threshold,
        'ip_asset_threshold': ip_threshold,
        'enable_ai_assessment': True
    }, ai_analyzer=mock_ai_analyzer)
    
    # Add ip_asset_count to vulnerability
    vuln_with_ip = {**vuln, 'ip_asset_count': ip_asset_count}
    
    # Mock GitHub stars check
    github_pass = github_stars >= github_threshold
    with patch.object(filter, '_check_github_stars', return_value=(github_pass, github_stars)):
        result = filter.filter_single(vuln_with_ip)
    
    # Calculate if basic filters pass
    ip_pass = ip_asset_count >= ip_threshold
    basic_filters_pass = github_pass and ip_pass
    
    # Property: AI assessment should only be called if basic filters pass
    if basic_filters_pass:
        mock_ai_analyzer.assess_vulnerability.assert_called_once()
    else:
        mock_ai_analyzer.assess_vulnerability.assert_not_called()


@given(vulnerability_strategy)
@settings(max_examples=50)
def test_property_ai_assessment_failure_handling(vuln: dict):
    """
    Feature: aggregator-advanced-features, Property 10: AI Assessment Failure Handling
    
    **Validates: Requirements 7.5**
    
    对于任意漏洞，如果 AI 评估失败（返回错误或超时），
    漏洞不应被过滤，应保留以供进一步处理。
    
    For any vulnerability where AI assessment fails (returns error or timeout),
    the vulnerability SHALL NOT be filtered out and SHALL be retained for
    further processing.
    """
    mock_ai_analyzer = MagicMock()
    # AI assessment returns None (failure)
    mock_ai_analyzer.assess_vulnerability.return_value = None
    
    filter = VulnerabilityFilter({
        'github_star_threshold': 0,  # Always pass
        'ip_asset_threshold': 0,     # Always pass
        'enable_ai_assessment': True
    }, ai_analyzer=mock_ai_analyzer)
    
    # Mock GitHub stars to always pass
    with patch.object(filter, '_check_github_stars', return_value=(True, 1000)):
        result = filter.filter_single(vuln)
    
    # Property: On AI failure, vulnerability should be RETAINED
    assert result.passed is True, \
        "Vulnerability should be retained when AI assessment fails"
